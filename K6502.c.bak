/*===================================================================*/
/*                                                                   */
/*  K6502.cpp : 6502 Emulator                                        */
/*                                                                   */
/*  2000/5/10   InfoNES Project ( based on pNesX )                   */
/*                                                                   */
/*===================================================================*/

/*-------------------------------------------------------------------*/
/*  Include files                                                    */
/*-------------------------------------------------------------------*/

//加速
#include "InfoNES.h"

#ifdef debug
#include "stdio.h"
#endif

#include "K6502.h"

#ifndef killsystem
#include "InfoNES_System.h"
#endif

#ifdef DTCM8K
#include "leonram.h"
#endif

#ifdef splitIO
#include "InfoNES_pAPU.h"
#endif

// Clock Op.
#define CLK(a)   g_dwPassedClocks += (a); total_cycles += (a);

// Addressing Op.
//从PRG或RAM中读取操作码或操作数，然后PC++。
#if PocketNES == 1
#define ReadPC(a)  a = *nes_pc++
#else
#define ReadPC(a)  \
	if( PC >= 0xC000 ) \
		a = ROMBANK2[ PC++ & 0x3fff ]; \
	else if( PC >= 0x8000 ) \
		a = ROMBANK0[ PC++ & 0x3fff ]; \
	else \
		a = RAM[ PC++ ]
#endif

//从PRG或RAM中读取操作数地址，然后PC++。
#if PocketNES == 1  
#define ReadPCW(a)  a = *nes_pc++; a |= *nes_pc++ << 8
#else
#define ReadPCW(a)  \
		if( PC >= 0xC000 ) \
		{ \
			a = ROMBANK2[ PC++ & 0x3fff ]; \
			a |= ROMBANK2[ PC++ & 0x3fff ] << 8; \
		} \
		else if( PC >= 0x8000 ) \
		{ \
			a = ROMBANK0[ PC++ & 0x3fff ]; \
			a |= ROMBANK0[ PC++ & 0x3fff ] << 8; \
		} \
		else \
		{ \
			a = RAM[ PC++ ]; \
			a |= RAM[ PC++ ] << 8; \
		}
#endif

//从PRG或RAM中读取操作数并加上nes_X，然后PC++。，可以视游戏的兼容情况而决定是否将其改为上面一行。
//#define ReadPCX(a)  \
//	if( PC >= 0xC000 ) \
//		a = (BYTE)( ROMBANK2[ PC++ & 0x3fff ] + nes_X ); \
//	else if( PC >= 0x8000 ) \
//		a = (BYTE)( ROMBANK0[ PC++ & 0x3fff ] + nes_X ); \
//	else \
//		a = (BYTE)( RAM[ PC++ ] + nes_X)
#if PocketNES == 1  
#define ReadPCX(a)  a = (BYTE)( *nes_pc++ + nes_X )	//经测试VCD游戏光盘中CIRCUS和Dragon Unit两款游戏只能使用上面一行
//#define ReadPCX(a)  a = *nes_pc++ + nes_X
#else
#define ReadPCX(a)  \
	if( PC >= 0xC000 ) \
		a = ROMBANK2[ PC++ & 0x3fff ] + nes_X; \
	else if( PC >= 0x8000 ) \
		a = ROMBANK0[ PC++ & 0x3fff ] + nes_X; \
	else \
		a = RAM[ PC++ ] + nes_X
#endif

//从PRG或RAM中读取操作数并加上nes_Y，然后PC++。
#if PocketNES == 1  
#define ReadPCY(a)  a = *nes_pc++ + nes_Y
#else
#define ReadPCY(a)  \
	if( PC >= 0xC000 ) \
		a = ROMBANK2[ PC++ & 0x3fff ] + nes_Y; \
	else if( PC >= 0x8000 ) \
		a = ROMBANK0[ PC++ & 0x3fff ] + nes_Y; \
	else \
		a = RAM[ PC++ ] + nes_X
#endif

//从RAM中读取操作数地址。
#define ReadZpW(a)  a = RAM[ a ] | ( RAM[ a + 1 ] << 8 )
//从RAM中读取操作数。
#define ReadZp(a)  byD0 = RAM[ a ]

//向RAM中写入操作数，可以视游戏的兼容情况而决定是否将其改为上面两行之一。
//#define WriteZp(a, b)  RAM[ a & 0x7ff ] = RAM[ a & 0xfff ] = RAM[ a & 0x17ff ] = RAM[ a & 0x1fff ] = b
//#define WriteZp(a, b)  RAM[ a & 0x7ff ] = b
#define WriteZp(a, b)  RAM[ a ] = b

//从6502RAM中读取操作数。
#ifdef killif
#define Read6502RAM(a)  byD0 = ( *readmem_tbl[ a >> 13 ] )( a )
//#define Read6502RAM(a)  byD0 = ( *(readmem_tbl + ( a >> 13 ) ) )( a )
#else /* killif */

#ifdef killif3
//#define Read6502RAM(a)  \
//	if( a >> 15 || !(a >> 13) ) \
//		byD0 = memmap_tbl[ a >> 13 ][ a ]; \
//	else \
//		byD0 = K6502_ReadIO( a );
#define Read6502RAM(a)  \
	if( a >= 0x8000 || a < 0x2000 ) \
		byD0 = memmap_tbl[ a >> 13 ][ a ]; \
	else \
		byD0 = K6502_ReadIO( a );
#else /* killif3 */
#define Read6502RAM(a)  \
	if( a >= 0xC000 ) \
		byD0 = ROMBANK2[ a & 0x3fff ]; \
	else if( a >= 0x8000 ) \
		byD0 = ROMBANK0[ a & 0x3fff ]; \
	else if( a < 0x2000 ) \
		byD0 = RAM[ a ]; \
	else \
		byD0 = K6502_ReadIO( a )
#endif /* killif3 */

#endif /* killif */

//向6502RAM中写入操作数。
#ifdef killif
#define Write6502RAM(a, b)  ( *writemem_tbl[ a >> 13 ] )( a, b )
#else /* killif */

#ifdef killwif
#define Write6502RAM(a, b)  ( *writemem_tbl[ a >> 13 ] )( a, b )
#else /* killwif */

#ifdef writeIO

//这里之所以将标准的“a < 0x8000”改为“a < 0x6000”是为了兼容BIN文件里人为修改的游戏代码
#ifdef damnBIN
#define Write6502RAM(a, b)  \
		if( a < 0x2000 ) \
			WriteZp( a, b ); \
		else if( a < 0x6000 ) \
			K6502_WriteIO( a, b ); \
		else \
			MapperWrite( a, b )
#else /* damnBIN */
#define Write6502RAM(a, b)  \
		if( a < 0x2000 ) \
			WriteZp( a, b ); \
		else if( a < 0x8000 ) \
			K6502_WriteIO( a, b ); \
		else \
			MapperWrite( a, b )
#endif /* damnBIN */

#else /* writeIO */
#define Write6502RAM(a, b)  \
		if( a < 0x2000 ) \
			WriteZp( a, b ); \
		else if( a < 0x4000 ) \
			{ /*if ( FrameCnt == 0 || FrameCnt == 1 ||FrameCnt == FrameSkip )*/ K6502_WritePPU( a, b ); } \
		else if( a < 0x8000 ) \
			K6502_WriteAPU( a, b ); \
		else \
			MapperWrite( a, b )
#endif /* writeIO */

#endif /* killwif */

#endif /* killif */

// Flag Op.
#define SETF(a)  nes_F |= (a)
#define RSTF(a)  nes_F &= ~(a)
#define TEST(a)  RSTF( FLAG_N | FLAG_Z ); SETF( g_byTestTable[ a ] )

// Stack Op.
#define PUSH(a)   RAM[ BASE_STACK + nes_SP-- ] = (a) 
#define PUSHW(a)  PUSH( (a) >> 8 ); PUSH( (a) & 0xff )
#define POP(a)    a = RAM[ BASE_STACK + ++nes_SP ]
#define POPW(a)   POP(a); a |= ( RAM[ BASE_STACK + ++nes_SP ] << 8 )

// Shift Op.
#ifdef killtable

#define M_FL(Rg)	nes_F = ( nes_F & ~( FLAG_Z | FLAG_N ) ) | g_byTestTable[ Rg ]

#define M_ASL(Rg)	nes_F &= ~FLAG_C; nes_F |= Rg >> 7; Rg <<= 1; M_FL(Rg)
#define M_LSR(Rg)	nes_F &= ~FLAG_C; nes_F |= Rg & FLAG_C; Rg >>= 1; M_FL(Rg)
#define M_ROL(Rg)	byD1 = ( Rg << 1 ) | ( nes_F & FLAG_C ); \
					nes_F &= ~FLAG_C; nes_F |= Rg >> 7; Rg = byD1; \
					M_FL(Rg)
#define M_ROR(Rg)	byD1 = ( Rg >> 1 ) | ( nes_F << 7 ); \
					nes_F &= ~FLAG_C; nes_F |= Rg & FLAG_C; Rg = byD1; \
					M_FL(Rg)

#define ASLA	M_ASL(nes_A) 
#define ASL		M_ASL(byD0)
#define LSRA	M_LSR(nes_A) 
#define LSR		M_LSR(byD0)
#define ROLA	M_ROL(nes_A)
#define ROL		M_ROL(byD0)
#define RORA	M_ROR(nes_A)
#define ROR		M_ROR(byD0)

#else /* killtable */

#define ASLA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ASLTable[ nes_A ].byFlag ); nes_A = g_ASLTable[ nes_A ].byValue 
#define LSRA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_LSRTable[ nes_A ].byFlag ); nes_A = g_LSRTable[ nes_A ].byValue 
#define ROLA    byD0 = nes_F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ROLTable[ byD0 ][ nes_A ].byFlag ); nes_A = g_ROLTable[ byD0 ][ nes_A ].byValue 
#define RORA    byD0 = nes_F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_RORTable[ byD0 ][ nes_A ].byFlag ); nes_A = g_RORTable[ byD0 ][ nes_A ].byValue 

#endif /* killtable */

//作用于ASL LSR ROL ROR四类对6502RAM进行位操作的指令
#ifdef HACK
#define Bit6502RAM(a)  byD0 = RAM[ wA0 ]; WriteZp( wA0, a )				//稍微不能确定，需测遍所有的游戏
#else /* HACK */
#define Bit6502RAM(a)  \
		if( wA0 < 0x2000 ) \
			{ byD0 = RAM[ wA0 ]; WriteZp( wA0, a ); } \
		else if( wA0 < 0x4000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); K6502_WritePPU( wA0, a ); } \
		else if( wA0 < 0x8000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); K6502_WriteAPU( wA0, a ); } \
		else if( wA0 < 0xC000 ) \
			{ byD0 = ROMBANK0[ wA0 & 0x3fff ]; MapperWrite( wA0, a ); } \
		else \
			{ byD0 = ROMBANK2[ wA0 & 0x3fff ]; MapperWrite( wA0, a ); }
#endif /* HACK */

// Math Op. (nes_A D flag isn't being supported.)
//作用于对6502RAM进行减一操作的DEC指令
#ifdef HACK
#define DEC6502RAM  byD0 = RAM[ wA0 ] - 1; WriteZp( wA0, byD0 )			//应该能确定
#else /* HACK */
#define DEC6502RAM  \
		if( wA0 < 0x2000 ) \
			{ byD0 = RAM[ wA0 ]; --byD0; WriteZp( wA0, byD0 ); } \
		else if( wA0 < 0x4000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); --byD0; K6502_WritePPU( wA0, byD0 ); } \
		else if( wA0 < 0x8000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); --byD0; K6502_WriteAPU( wA0, byD0 ); } \
		else if( wA0 < 0xC000 ) \
			{ byD0 = ROMBANK0[ wA0 & 0x3fff ]; --byD0; MapperWrite( wA0, byD0 ); } \
		else \
			{ byD0 = ROMBANK2[ wA0 & 0x3fff ]; --byD0; MapperWrite( wA0, byD0 ); }
#endif /* HACK */
//作用于对6502RAM进行加一操作的INC命令
#ifdef HACK
#define INC6502RAM  byD0 = RAM[ wA0 ] + 1; WriteZp( wA0, byD0 )			//应该能确定
#else /* HACK */
#define INC6502RAM  \
		if( wA0 < 0x2000 ) \
			{ byD0 = RAM[ wA0 ]; ++byD0; WriteZp( wA0, byD0 ); } \
		else if( wA0 < 0x4000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); ++byD0; K6502_WritePPU( wA0, byD0 ); } \
		else if( wA0 < 0x8000 ) \
			{ byD0 = K6502_ReadIO( wA0 ); ++byD0; K6502_WriteAPU( wA0, byD0 ); } \
		else if( wA0 < 0xC000 ) \
			{ byD0 = ROMBANK0[ wA0 & 0x3fff ]; ++byD0; MapperWrite( wA0, byD0 ); } \
		else \
			{ byD0 = ROMBANK2[ wA0 & 0x3fff ]; ++byD0; MapperWrite( wA0, byD0 ); }
#endif /* HACK */

// Jump Op.
#define BRA(a) { \
  if ( a ) \
  { \
	ReadPC( BRAdisp ); \
    /*BRAtemp = nes_pc;*/ \
	nes_pc += BRAdisp; \
	CLK( 3 /*+ ( ( BRAtemp & 0x0100 ) != ( nes_pc & 0x0100 ) )*/ ); \
  } else { \
	++nes_pc; \
	CLK( 2 ); \
  } \
}

/*-------------------------------------------------------------------*/
/*  Global valiables                                                 */
/*-------------------------------------------------------------------*/

// 6502 Register

#if PocketNES == 1
register BYTE *nes_pc asm("g5");			//为了避免每次读取一个指令时就判断一次指令的位置，参考PocketNES中的汇编代码，引入指向指令的指针
register BYTE *lastbank asm("g7");
#define encodePC lastbank = memmap_tbl[ ((WORD)nes_pc) >> 13 ]; nes_pc = lastbank + (WORD)nes_pc

//BYTE *pSpPC[ 256 ];
//BYTE SpPC = 0;
//#define PUSH32(a) pSpPC[ SpPC++ ] = a;
//#define POP32(a) a = pSpPC[ SpPC-- ];

#else
WORD PC;
#endif

//g1,g3不能用

#ifdef WIN32
BYTE nes_SP;
BYTE nes_F ;
BYTE nes_A;
BYTE nes_X ;
BYTE nes_Y ;
#else /* WIN32 */
/*register*/ BYTE nes_SP /*asm("g7")*/;
register BYTE nes_F asm("g6");
register BYTE nes_A asm("g2");
register BYTE nes_X asm("g4");
/*register*/ BYTE nes_Y /*asm("g5")*/;
#endif /* WIN32 */

// The number of the clocks that it passed
unsigned int g_dwPassedClocks;

//APU 6502运行以来所经过的时钟周期总数
DWORD total_cycles;

// nes_A table for the test
//BYTE g_byTestTable[ 256 ];
/*const*/ BYTE g_byTestTable[ 256 ] = {
0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80};

/*===================================================================*/
/*                                                                   */
/*                K6502_Init() : Initialize K6502                    */
/*                                                                   */
/*===================================================================*/
#ifndef killsystem
void K6502_Init()
{
}
#endif /* killsystem */


/*-------------------------------------------------------------------*/
/*  Mapper Function                                                  */
/*-------------------------------------------------------------------*/

void (*MapperWrite)( WORD wAddr, BYTE byData );


void Map0_Write( WORD wAddr, BYTE byData )
{
}
void Map2_Write( WORD wAddr, BYTE byData )
{
	/* Set ROM Banks */
#ifdef HACK
	//ROMBANK0 = ROM + byData * 0x4000;
	ROMBANK0 = ROM + ( byData << 14 );
	ROMBANK1 = ROMBANK0 + 0x2000;
#else
	byData &= 7;
	byData <<= 1;

	ROMBANK0 = ROMPAGE( byData );
	ROMBANK1 = ROMPAGE( byData + 1 );
#endif

	memmap_tbl[ 4 ] = ROMBANK0 - 0x8000;		//这里- 0x8000是为了在encodePC中不用再做& 0x1FFF的运算了，下同
	memmap_tbl[ 5 ] = ROMBANK1 - 0xA000;
}
void Map3_Write( WORD wAddr, BYTE byData )
{
	DWORD dwBase;

	/* Set PPU Banks */
#ifdef killsystem
    byData &= VRomSize - 1;
#else
    byData &= NesHeader.byVRomSize - 1;
#endif
	dwBase = ( (DWORD)byData ) << 3;

	PPUBANK[ 0 ] = VROMPAGE( dwBase + 0 );
	PPUBANK[ 1 ] = VROMPAGE( dwBase + 1 );
	PPUBANK[ 2 ] = VROMPAGE( dwBase + 2 );
	PPUBANK[ 3 ] = VROMPAGE( dwBase + 3 );
	PPUBANK[ 4 ] = VROMPAGE( dwBase + 4 );
	PPUBANK[ 5 ] = VROMPAGE( dwBase + 5 );
	PPUBANK[ 6 ] = VROMPAGE( dwBase + 6 );
	PPUBANK[ 7 ] = VROMPAGE( dwBase + 7 );

	NES_ChrGen = PPUBANK[ ( PPU_R0 & R0_BG_ADDR ) >> 2];
	NES_SprGen = PPUBANK[ ( PPU_R0 & R0_SP_ADDR ) >> 1];
}

/*===================================================================*/
/*                                                                   */
/*                K6502_Reset() : Reset a CPU                        */
/*                                                                   */
/*===================================================================*/
#ifndef move6502reset
void K6502_Reset()
{
/*
 *  Reset a CPU
 *
 */
  /*-------------------------------------------------------------------*/
  /*  Initialize Mapper                                                */
  /*-------------------------------------------------------------------*/
  int nPage;

  if( MapperNo == 0 )
  {
	  /* Write to Mapper */
	  MapperWrite = Map0_Write;

	  /* Set ROM Banks */
#ifdef killsystem
	  if ( RomSize > 1 )
#else
	  if ( NesHeader.byRomSize > 1 )
#endif
	  {
		  ROMBANK0 = ROMPAGE( 0 );
		  ROMBANK1 = ROMPAGE( 1 );
		  ROMBANK2 = ROMPAGE( 2 );
		  ROMBANK3 = ROMPAGE( 3 );
	  }
#ifdef killsystem
	  else if ( RomSize > 0 )
#else
	  else if ( NesHeader.byRomSize > 0 )
#endif
	  {
		  ROMBANK0 = ROMPAGE( 0 );
		  ROMBANK1 = ROMPAGE( 1 );
		  ROMBANK2 = ROMPAGE( 0 );
		  ROMBANK3 = ROMPAGE( 1 );
	  } else {
		  ROMBANK0 = ROMPAGE( 0 );
		  ROMBANK1 = ROMPAGE( 0 );
		  ROMBANK2 = ROMPAGE( 0 );
		  ROMBANK3 = ROMPAGE( 0 );
	  }

	  /* Set PPU Banks */
	  for ( nPage = 0; nPage < 8; ++nPage )
		  PPUBANK[ nPage ] = VROMPAGE( nPage );
  }
  else if( MapperNo == 2 )
  {
	  /* Write to Mapper */
	  MapperWrite = Map2_Write;

	  /* Set ROM Banks */
	  ROMBANK0 = ROM;
	  ROMBANK1 = ROM + 0x2000;
	  ROMBANK2 = ROM + 0x1C000;
	  ROMBANK3 = ROM + 0x1E000;

#ifdef splitPPURAM
	  /* Set PPU Banks */
	  for ( nPage = 0; nPage < 8; ++nPage )
		  //PPUBANK[ nPage ] = &PTRAM[ nPage * 0x400 ];
		  PPUBANK[ nPage ] = &PTRAM[ nPage << 10];
#endif /* splitPPURAM */
  }

#ifdef killsystem
  else
#else
  else if( MapperNo == 3 )
#endif /* killsystem */
  {
	  /* Write to Mapper */
	  MapperWrite = Map3_Write;

	  /* Set ROM Banks */
#ifdef killsystem
	  if ( ( RomSize << 1 ) > 2 )
#else
	  if ( ( NesHeader.byRomSize << 1 ) > 2 )
#endif /* killsystem */
	  {
		  ROMBANK0 = ROMPAGE( 0 );
		  ROMBANK1 = ROMPAGE( 1 );
		  ROMBANK2 = ROMPAGE( 2 );
		  ROMBANK3 = ROMPAGE( 3 );    
	  } else {
		  ROMBANK0 = ROMPAGE( 0 );
		  ROMBANK1 = ROMPAGE( 1 );
		  ROMBANK2 = ROMPAGE( 0 );
		  ROMBANK3 = ROMPAGE( 1 );
	  }

	  /* Set PPU Banks */
	  for ( nPage = 0; nPage < 8; ++nPage )
		  PPUBANK[ nPage ] = VROMPAGE( nPage );
  }
#ifndef killsystem
  else
  {
    // Non support mapper
    InfoNES_MessageBox( "Current mapper is unsupported.\n" );
    //return -1;
  }
#endif /* killsystem */

  // Reset Registers

#if PocketNES == 1

#ifdef killwif
	writemem_tbl[ 0 ] = ram_W;		//$0000
	writemem_tbl[ 1 ] = PPU_W;		//$2000
	writemem_tbl[ 2 ] = APU_W;		//$4000
	//writemem_tbl[ 3 ] = sram_W;	//$6000
	writemem_tbl[ 3 ] = rom_W80;	//$8000
	writemem_tbl[ 4 ] = rom_W80;	//$8000
	writemem_tbl[ 5 ] = rom_WA0;	//$A000
	writemem_tbl[ 6 ] = rom_WC0;	//$C000
	writemem_tbl[ 7 ] = rom_WE0;	//$E000
#endif /* killwif */


#ifdef killif
	readmem_tbl[ 0 ] = ram_R;	//$0000
	readmem_tbl[ 1 ] = PPU_R;	//$2000
	readmem_tbl[ 2 ] = APU_R;	//$4000
	//readmem_tbl[ 3 ] = sram_R;	//$6000
	readmem_tbl[ 4 ] = rom_R80;	//$8000
	readmem_tbl[ 5 ] = rom_RA0;	//$A000
	readmem_tbl[ 6 ] = rom_RC0;	//$C000
	readmem_tbl[ 7 ] = rom_RE0;	//$E000

	writemem_tbl[ 0 ] = ram_W;		//$0000
	writemem_tbl[ 1 ] = PPU_W;		//$2000
	writemem_tbl[ 2 ] = APU_W;		//$4000
	//writemem_tbl[ 3 ] = sram_W;	//$6000
	writemem_tbl[ 3 ] = rom_W80;	//$8000
	writemem_tbl[ 4 ] = rom_W80;	//$8000
	writemem_tbl[ 5 ] = rom_WA0;	//$A000
	writemem_tbl[ 6 ] = rom_WC0;	//$C000
	writemem_tbl[ 7 ] = rom_WE0;	//$E000
#endif /* killif */

#ifdef killif2
	memmap_tbl[ 0 ] = RAM;
#else /* killif2 */
	//memmap_tbl[ 0 ] = RAM;
#endif /* killif2 */

	//memmap_tbl[ 1 ] = ( BYTE *)K6502_ReadIO;
	//memmap_tbl[ 2 ] = ( BYTE *)K6502_ReadIO;
	memmap_tbl[ 3 ] = SRAM;
	memmap_tbl[ 4 ] = ROMBANK0 - 0x8000;		//这里- 0x8000是为了在encodePC中不用再做& 0x1FFF的运算了，下同
	memmap_tbl[ 5 ] = ROMBANK1 - 0xA000;
	memmap_tbl[ 6 ] = ROMBANK2 - 0xC000;
	memmap_tbl[ 7 ] = ROMBANK3 - 0xE000;
	nes_pc = (BYTE*)(ROMBANK3[ 0x1FFC ] | ROMBANK3[ 0x1FFD ] << 8);//加速K6502_ReadW( VECTOR_RESET );
	encodePC;
#else
	PC = ROMBANK2[ 0x3FFC ] | ROMBANK2[ 0x3FFD ] << 8;//加速K6502_ReadW( VECTOR_RESET );
#endif

  nes_SP = 0xFF;
  nes_A = nes_X = nes_Y = 0;
  nes_F = FLAG_Z | FLAG_R | FLAG_I;

  //// Set up the state of the Interrupt pin.
  //NMI_State = NMI_Wiring;
  //IRQ_State = IRQ_Wiring;

  // Reset Passed Clocks
  g_dwPassedClocks = 0;

  //APU
  total_cycles = 0;
}
#endif /* move6502reset */

/*===================================================================*/
/*                                                                   */
/*    K6502_Set_Int_Wiring() : Set up wiring of the interrupt pin    */
/*                                                                   */
/*===================================================================*/
//void K6502_Set_Int_Wiring( BYTE byNMI_Wiring, BYTE byIRQ_Wiring )
//{
///*
// * Set up wiring of the interrupt pin
// *
// */
//
//  NMI_Wiring = byNMI_Wiring;
//  IRQ_Wiring = byIRQ_Wiring;
//}

//nesterJ
void K6502_NMI()			//执行NMI中断
{
	//if ( NMI_State != NMI_Wiring )
	//{
	//	// NMI Interrupt
	//	NMI_State = NMI_Wiring;
		CLK( 7 );

#if PocketNES == 1
		  nes_pc -= (DWORD)lastbank;
		  PUSHW( (WORD)nes_pc ); PUSH( nes_F & ~FLAG_B ); RSTF( FLAG_D ); SETF( FLAG_I );
		  nes_pc = (BYTE *)( ROMBANK3[ 0x1FFA ] | ROMBANK3[ 0x1FFB ] << 8 );
		  encodePC;
#else

		PUSHW( PC );
		PUSH( nes_F & ~FLAG_B );

		RSTF( FLAG_D );
		SETF( FLAG_I );

		PC = ROMBANK2[ 0x3FFA ] | ROMBANK2[ 0x3FFB ] << 8;//加速 K6502_ReadW( VECTOR_NMI );
	//}
#endif
}

/*===================================================================*/
/*                                                                   */
/*  K6502_Step() :                                                   */
/*          Only the specified number of the clocks execute Op.      */
/*                                                                   */
/*===================================================================*/
void K6502_Step( WORD wClocks )
{
/*
 *  Only the specified number of the clocks execute Op.
 *
 *  Parameters
 *    WORD wClocks              (Read)
 *      The number of the clocks
 */

  BYTE byCode;
  signed char BRAdisp;

//#if PocketNES == 1
//  BYTE *BRAtemp;
//#endif

  register WORD wA0;
  WORD wA1;
  BYTE byD0;
  BYTE byD1;
  WORD wD0;

#ifdef debug
	printf("6");
#endif


  //// Dispose of it if there is an interrupt requirement
  //if ( NMI_State != NMI_Wiring )
  //{
  //  // NMI Interrupt
  //  NMI_State = NMI_Wiring;
  //  CLK( 7 );

  //  PUSHW( PC );
  //  PUSH( nes_F & ~FLAG_B );

  //  RSTF( FLAG_D );
  //  SETF( FLAG_I );

  //  PC = ROMBANK2[ 0x3FFA ] | ROMBANK2[ 0x3FFB ] << 8;//加速 K6502_ReadW( VECTOR_NMI );
  //}
  ////else
  //if ( IRQ_State != IRQ_Wiring )
  //{
  //  // IRQ Interrupt
  //  // Execute IRQ if an I flag isn't being set
  //  if ( !( nes_F & FLAG_I ) )
  //  {
  //    IRQ_State = IRQ_Wiring;
  //    CLK( 7 );

  //    PUSHW( PC );
  //    PUSH( nes_F & ~FLAG_B );

  //    RSTF( FLAG_D );
  //    SETF( FLAG_I );
  //  
  //    PC = ROMBANK2[ 0x3FFE ] | ROMBANK2[ 0x3FFF ] << 8;//加速 K6502_ReadW( VECTOR_IRQ );
  //  }
  //}

  // It has a loop until a constant clock passes
  while ( g_dwPassedClocks < wClocks )
  {
    // Read an instruction
    //byCode = K6502_ReadPC( PC++ );

//加速
//byCode = ReadPC[ PC - 0x8000 ]( PC ); PC++;

	  //if( PC >= 0x8000 )
	  //{
		 // byCode = *( *ReadPC[ PC - 0x8000 ] + ( PC & 0x1fff) );
		 // PC++;
	  //}
	  //else
		 // byCode = RAM[ PC++ ];

	  //if( PC > 0xDFFF )
		 // byCode = ROMBANK3[ PC++ & 0x1fff ];
	  //else if( PC > 0xBFFF )
		 // byCode = ROMBANK2[ PC++ & 0x1fff ];
	  //else if( PC > 0x9FFF )
		 // byCode = ROMBANK1[ PC++ & 0x1fff ];
	  //else if( PC > 0x7FFF )
		 // byCode = ROMBANK0[ PC++ & 0x1fff ];
	  //else
		 // byCode = RAM[ PC++ ];

	  //if( PC > 0x7fff )
	  //{
	  //    if( PC > 0xBFFF )
		 //     byCode = ROMBANK2[ PC++ & 0x3fff ];
		 // else
			//  byCode = ROMBANK0[ PC++ & 0x3fff ];
	  //}
	  //else
		 // byCode = RAM[ PC++ ];

#if PocketNES == 1
	  byCode = *nes_pc++;

	 // {
	 // 	static BYTE temp = 0;
	 // 	if (temp != nes_A) printf("(nes_A=%x)\n",nes_A);
	 //	temp = nes_A;
	 //}
	 // if(nes_pc - (DWORD)lastbank == 0x8095)
	 // {
	 // 	static int i;
	 // 	i++;
	 // 	}
  //   printf("[%x:%x:%x]", nes_pc - (DWORD)lastbank, byCode, byData );

#ifdef debug6502asm
     printf("\n%x: %x", nes_pc - (DWORD)lastbank, byCode );
#endif /* debug6502asm */

#else
		if( PC >= 0xC000 )
			byCode = ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			byCode = ROMBANK0[ PC++ & 0x3fff ];
		else
			byCode = RAM[ PC++ ];
#endif

    //byCode = K6502_ReadPC( PC++ );

	//   if( PC >= 0xC000 )
		 // byCode = ROMBANK2[ PC++ - 0xC000 ];
	  //else if( PC >= 0x8000 )
		 // byCode = ROMBANK0[ PC++ - 0x8000 ];
	  //else
		 // byCode = RAM[ PC++ ];

   //   if( PC >= 0xC000 )
		 // byCode = ROMBANK2[ PC++ & 0x3fff ];
	  //else
		 // byCode = ROMBANK0[ PC++ & 0x3fff ];

//byCode = *( PAGE + PC++ - 0x8000);

    // Execute an instruction.
    switch ( byCode )
    {

		//Map4
/*      case 0x00:  // BRK
        ++PC; PUSHW( PC ); SETF( FLAG_B ); PUSH( nes_F ); SETF( FLAG_I ); RSTF( FLAG_D ); PC = K6502_ReadW( VECTOR_IRQ ); CLK( 7 );
        break;

      case 0x01:  // ORA (Zpg,nes_X)
        ORA( A_IX ); CLK( 6 );
        break;

      case 0x05:  // ORA Zpg
        ORA( A_ZP ); CLK( 3 );
        break;

      case 0x06:  // ASL Zpg
        ASL( AA_ZP ); CLK( 5 );
        break;

      case 0x08:  // PHP
        SETF( FLAG_B ); PUSH( nes_F ); CLK( 3 );
        break;

      case 0x09:  // ORA #Oper
        ORA( A_IMM ); CLK( 2 );
        break;

      case 0x0A:  // ASL nes_A
        ASLA; CLK( 2 );
        break;

      case 0x0D:  // ORA Abs
        ORA( A_ABS ); CLK( 4 );
        break;

      case 0x0e:  // ASL Abs 
        ASL( AA_ABS ); CLK( 6 );
        break;

      case 0x10: // BPL Oper
        BRA( !( nes_F & FLAG_N ) );
        break;

      case 0x11: // ORA (Zpg),nes_Y
        ORA( A_IY ); CLK( 5 );
        break;

      case 0x15: // ORA Zpg,nes_X
        ORA( A_ZPX ); CLK( 4 );
        break;

      case 0x16: // ASL Zpg,nes_X
        ASL( AA_ZPX ); CLK( 6 );
        break;

      case 0x18: // CLC
        RSTF( FLAG_C ); CLK( 2 );
        break;

      case 0x19: // ORA Abs,nes_Y
        ORA( A_ABSY ); CLK( 4 );
        break;

      case 0x1D: // ORA Abs,nes_X
        ORA( A_ABSX ); CLK( 4 );
        break;

      case 0x1E: // ASL Abs,nes_X
        ASL( AA_ABSX ); CLK( 7 );
        break;

      case 0x20: // JSR Abs
        JSR; CLK( 6 );
        break;

      case 0x21: // AND (Zpg,nes_X)
        AND( A_IX ); CLK( 6 );
        break;

      case 0x24: // BIT Zpg
        BIT( A_ZP ); CLK( 3 );
        break;

      case 0x25: // AND Zpg
        AND( A_ZP ); CLK( 3 );
        break;

      case 0x26: // ROL Zpg
        ROL( AA_ZP ); CLK( 5 );
        break;

      case 0x28: // PLP
        POP( nes_F ); SETF( FLAG_R ); CLK( 4 );
        break;

      case 0x29: // AND #Oper
        AND( A_IMM ); CLK( 2 );
        break;

      case 0x2A: // ROL nes_A
        ROLA; CLK( 2 );
        break;

      case 0x2C: // BIT Abs
        BIT( A_ABS ); CLK( 4 );
        break;

      case 0x2D: // AND Abs 
        AND( A_ABS ); CLK( 4 );
        break;

      case 0x2E: // ROL Abs
        ROL( AA_ABS ); CLK( 6 );
        break;

      case 0x30: // BMI Oper 
        BRA( nes_F & FLAG_N );
        break;

      case 0x31: // AND (Zpg),nes_Y
        AND( A_IY ); CLK( 5 );
        break;

      case 0x35: // AND Zpg,nes_X
        AND( A_ZPX ); CLK( 4 );
        break;

      case 0x36: // ROL Zpg,nes_X
        ROL( AA_ZPX ); CLK( 6 );
        break;

      case 0x38: // SEC
        SETF( FLAG_C ); CLK( 2 );
        break;

      case 0x39: // AND Abs,nes_Y
        AND( A_ABSY ); CLK( 4 );
        break;

      case 0x3D: // AND Abs,nes_X
        AND( A_ABSX ); CLK( 4 );
        break;

      case 0x3E: // ROL Abs,nes_X
        ROL( AA_ABSX ); CLK( 7 );
        break;

      case 0x40: // RTI
        POP( nes_F ); SETF( FLAG_R ); POPW( PC ); CLK( 6 );
        break;

      case 0x41: // EOR (Zpg,nes_X)
        EOR( A_IX ); CLK( 6 );
        break;

      case 0x45: // EOR Zpg
        EOR( A_ZP ); CLK( 3 );
        break;

      case 0x46: // LSR Zpg
        LSR( AA_ZP ); CLK( 5 );
        break;

      case 0x48: // PHA
        PUSH( nes_A ); CLK( 3 );
        break;

      case 0x49: // EOR #Oper
        EOR( A_IMM ); CLK( 2 );
        break;

      case 0x4A: // LSR nes_A
        LSRA; CLK( 2 );
        break;

      case 0x4C: // JMP Abs
        JMP( AA_ABS ); CLK( 3 );
        break;

      case 0x4D: // EOR Abs
        EOR( A_ABS ); CLK( 4 );
        break;

      case 0x4E: // LSR Abs
        LSR( AA_ABS ); CLK( 6 );
        break;

      case 0x50: // BVC
        BRA( !( nes_F & FLAG_V ) );
        break;

      case 0x51: // EOR (Zpg),nes_Y
        EOR( A_IY ); CLK( 5 );
        break;

      case 0x55: // EOR Zpg,nes_X
        EOR( A_ZPX ); CLK( 4 );
        break;

      case 0x56: // LSR Zpg,nes_X
        LSR( AA_ZPX ); CLK( 6 );
        break;

      case 0x58: // CLI
        byD0 = nes_F;
        RSTF( FLAG_I ); CLK( 2 );
        if ( ( byD0 & FLAG_I ) && IRQ_State != IRQ_Wiring )  
        {
          IRQ_State = IRQ_Wiring;          
          CLK( 7 );

          PUSHW( PC );
          PUSH( nes_F & ~FLAG_B );

          RSTF( FLAG_D );
          SETF( FLAG_I );
    
          PC = K6502_ReadW( VECTOR_IRQ );
        }
        break;

      case 0x59: // EOR Abs,nes_Y
        EOR( A_ABSY ); CLK( 4 );
        break;

      case 0x5D: // EOR Abs,nes_X
        EOR( A_ABSX ); CLK( 4 );
        break;

      case 0x5E: // LSR Abs,nes_X
        LSR( AA_ABSX ); CLK( 7 );
        break;

      case 0x60: // RTS
        POPW( PC ); ++PC; CLK( 6 );
        break;

      case 0x61: // ADC (Zpg,nes_X)
        ADC( A_IX ); CLK( 6 );
        break;

      case 0x65: // ADC Zpg
        ADC( A_ZP ); CLK( 3 );
        break;

      case 0x66: // ROR Zpg
        ROR( AA_ZP ); CLK( 5 );
        break;

      case 0x68: // PLA
        POP( nes_A ); TEST( nes_A ); CLK( 4 );
        break;

      case 0x69: // ADC #Oper
        ADC( A_IMM ); CLK( 2 );
        break;

      case 0x6A: // ROR nes_A
        RORA; CLK( 2 );
        break;

      case 0x6C: // JMP (Abs)
        JMP( K6502_ReadW2( AA_ABS ) ); CLK( 5 );
        break;

      case 0x6D: // ADC Abs
        ADC( A_ABS ); CLK( 4 );
        break;

      case 0x6E: // ROR Abs
        ROR( AA_ABS ); CLK( 6 );
        break;

      case 0x70: // BVS
        BRA( nes_F & FLAG_V );
        break;

      case 0x71: // ADC (Zpg),nes_Y
        ADC( A_IY ); CLK( 5 );
        break;

      case 0x75: // ADC Zpg,nes_X
        ADC( A_ZPX ); CLK( 4 );
        break;

      case 0x76: // ROR Zpg,nes_X
        ROR( AA_ZPX ); CLK( 6 );
        break;

      case 0x78: // SEI
        SETF( FLAG_I ); CLK( 2 );
        break;

      case 0x79: // ADC Abs,nes_Y
        ADC( A_ABSY ); CLK( 4 );
        break;

      case 0x7D: // ADC Abs,nes_X
        ADC( A_ABSX ); CLK( 4 );
        break;

      case 0x7E: // ROR Abs,nes_X
        ROR( AA_ABSX ); CLK( 7 );
        break;

      case 0x81: // STA (Zpg,nes_X)
        STA( AA_IX ); CLK( 6 );
        break;
      
      case 0x84: // STY Zpg
        STY( AA_ZP ); CLK( 3 );
        break;

      case 0x85: // STA Zpg
        STA( AA_ZP ); CLK( 3 );
        break;

      case 0x86: // STX Zpg
        STX( AA_ZP ); CLK( 3 );
        break;

      case 0x88: // DEY
        --nes_Y; TEST( nes_Y ); CLK( 2 );
        break;

      case 0x8A: // TXA
        nes_A = nes_X; TEST( nes_A ); CLK( 2 );
        break;

      case 0x8C: // STY Abs
        STY( AA_ABS ); CLK( 4 );
        break;

      case 0x8D: // STA Abs
        STA( AA_ABS ); CLK( 4 );
        break;

      case 0x8E: // STX Abs
        STX( AA_ABS ); CLK( 4 );
        break;

      case 0x90: // BCC
        BRA( !( nes_F & FLAG_C ) );
        break;

      case 0x91: // STA (Zpg),nes_Y
        STA( AA_IY ); CLK( 6 );
        break;

      case 0x94: // STY Zpg,nes_X
        STY( AA_ZPX ); CLK( 4 );
        break;

      case 0x95: // STA Zpg,nes_X
        STA( AA_ZPX ); CLK( 4 );
        break;

      case 0x96: // STX Zpg,nes_Y
        STX( AA_ZPY ); CLK( 4 );
        break;

      case 0x98: // TYA
        nes_A = nes_Y; TEST( nes_A ); CLK( 2 );
        break;

      case 0x99: // STA Abs,nes_Y
        STA( AA_ABSY ); CLK( 5 );
        break;

      case 0x9A: // TXS
        nes_SP = nes_X; CLK( 2 );
        break;

      case 0x9D: // STA Abs,nes_X
        STA( AA_ABSX ); CLK( 5 );
        break;

      case 0xA0: // LDY #Oper
        LDY( A_IMM ); CLK( 2 );
        break;

      case 0xA1: // LDA (Zpg,nes_X)
        LDA( A_IX ); CLK( 6 );
        break;

      case 0xA2: // LDX #Oper
        LDX( A_IMM ); CLK( 2 );
        break;

      case 0xA4: // LDY Zpg
        LDY( A_ZP ); CLK( 3 );
        break;

      case 0xA5: // LDA Zpg
        LDA( A_ZP ); CLK( 3 );
        break;

      case 0xA6: // LDX Zpg
        LDX( A_ZP ); CLK( 3 );
        break;

      case 0xA8: // TAY
        nes_Y = nes_A; TEST( nes_A ); CLK( 2 );
        break;

      case 0xA9: // LDA #Oper
        LDA( A_IMM ); CLK( 2 );
        break;

      case 0xAA: // TAX
        nes_X = nes_A; TEST( nes_A ); CLK( 2 );
        break;

      case 0xAC: // LDY Abs
        LDY( A_ABS ); CLK( 4 );
        break;

      case 0xAD: // LDA Abs
        LDA( A_ABS ); CLK( 4 );
        break;

      case 0xAE: // LDX Abs
        LDX( A_ABS ); CLK( 4 );
        break;

      case 0xB0: // BCS
        BRA( nes_F & FLAG_C );
        break;

      case 0xB1: // LDA (Zpg),nes_Y
        LDA( A_IY ); CLK( 5 );
        break;

      case 0xB4: // LDY Zpg,nes_X
        LDY( A_ZPX ); CLK( 4 );
        break;

      case 0xB5: // LDA Zpg,nes_X
        LDA( A_ZPX ); CLK( 4 );
        break;

      case 0xB6: // LDX Zpg,nes_Y
        LDX( A_ZPY ); CLK( 4 );
        break;

      case 0xB8: // CLV
        RSTF( FLAG_V ); CLK( 2 );
        break;

      case 0xB9: // LDA Abs,nes_Y
        LDA( A_ABSY ); CLK( 4 );
        break;

      case 0xBA: // TSX
        nes_X = nes_SP; TEST( nes_X ); CLK( 2 );
        break;

      case 0xBC: // LDY Abs,nes_X
        LDY( A_ABSX ); CLK( 4 );
        break;

      case 0xBD: // LDA Abs,nes_X
        LDA( A_ABSX ); CLK( 4 );
        break;

      case 0xBE: // LDX Abs,nes_Y
        LDX( A_ABSY ); CLK( 4 );
        break;

      case 0xC0: // CPY #Oper
        CPY( A_IMM ); CLK( 2 );
        break;

      case 0xC1: // CMP (Zpg,nes_X)
        CMP( A_IX ); CLK( 6 );
        break;

      case 0xC4: // CPY Zpg
        CPY( A_ZP ); CLK( 3 );
        break;

      case 0xC5: // CMP Zpg
        CMP( A_ZP ); CLK( 3 );
        break;

      case 0xC6: // DEC Zpg
        DEC( AA_ZP ); CLK( 5 );
        break;

      case 0xC8: // INY
        ++nes_Y; TEST( nes_Y ); CLK( 2 );
        break;

      case 0xC9: // CMP #Oper
        CMP( A_IMM ); CLK( 2 );
        break;

      case 0xCA: // DEX
        --nes_X; TEST( nes_X ); CLK( 2 );
        break;

      case 0xCC: // CPY Abs
        CPY( A_ABS ); CLK( 4 );
        break;

      case 0xCD: // CMP Abs
        CMP( A_ABS ); CLK( 4 );
        break;

      case 0xCE: // DEC Abs
        DEC( AA_ABS ); CLK( 6 );
        break;

      case 0xD0: // BNE
        BRA( !( nes_F & FLAG_Z ) );
        break;

      case 0xD1: // CMP (Zpg),nes_Y
        CMP( A_IY ); CLK( 5 );
        break;

      case 0xD5: // CMP Zpg,nes_X
        CMP( A_ZPX ); CLK( 4 );
        break;

      case 0xD6: // DEC Zpg,nes_X
        DEC( AA_ZPX ); CLK( 6 );
        break;

      case 0xD8: // CLD
        RSTF( FLAG_D ); CLK( 2 );
        break;

      case 0xD9: // CMP Abs,nes_Y
        CMP( A_ABSY ); CLK( 4 );
        break;

      case 0xDD: // CMP Abs,nes_X
        CMP( A_ABSX ); CLK( 4 );
        break;

      case 0xDE: // DEC Abs,nes_X
        DEC( AA_ABSX ); CLK( 7 );
        break;

      case 0xE0: // CPX #Oper
        CPX( A_IMM ); CLK( 2 );
        break;

      case 0xE1: // SBC (Zpg,nes_X)
        SBC( A_IX ); CLK( 6 );
        break;

      case 0xE4: // CPX Zpg
        CPX( A_ZP ); CLK( 3 );
        break;

      case 0xE5: // SBC Zpg
        SBC( A_ZP ); CLK( 3 );
        break;

      case 0xE6: // INC Zpg
        INC( AA_ZP ); CLK( 5 );
        break;

      case 0xE8: // INX
        ++nes_X; TEST( nes_X ); CLK( 2 );
        break;

      case 0xE9: // SBC #Oper
        SBC( A_IMM ); CLK( 2 );
        break;

      case 0xEA: // NOP
        CLK( 2 );
        break;

      case 0xEC: // CPX Abs
        CPX( A_ABS ); CLK( 4 );
        break;

      case 0xED: // SBC Abs
        SBC( A_ABS ); CLK( 4 );
        break;

      case 0xEE: // INC Abs
        INC( AA_ABS ); CLK( 6 );
        break;

      case 0xF0: // BEQ
        BRA( nes_F & FLAG_Z );
        break;

      case 0xF1: // SBC (Zpg),nes_Y
        SBC( A_IY ); CLK( 5 );
        break;

      case 0xF5: // SBC Zpg,nes_X
        SBC( A_ZPX ); CLK( 4 );
        break;

      case 0xF6: // INC Zpg,nes_X
        INC( AA_ZPX ); CLK( 6 );
        break;

      case 0xF8: // SED
        SETF( FLAG_D ); CLK( 2 );
        break;

      case 0xF9: // SBC Abs,nes_Y
        SBC( A_ABSY ); CLK( 4 );
        break;

      case 0xFD: // SBC Abs,nes_X
        SBC( A_ABSX ); CLK( 4 );
        break;

      case 0xFE: // INC Abs,nes_X
        INC( AA_ABSX ); CLK( 7 );
        break;*/

//加速
      case 0x00:  // BRK
		  //++PC; PUSHW( PC ); SETF( FLAG_B ); PUSH( nes_F ); SETF( FLAG_I ); RSTF( FLAG_D ); PC = K6502_ReadW( VECTOR_IRQ ); CLK( 7 );

		  //加速
#if PocketNES == 1
		  nes_pc -= (DWORD)lastbank;
		  ++nes_pc;
		  PUSHW( (WORD)nes_pc ); SETF( FLAG_B ); PUSH( nes_F ); SETF( FLAG_I ); RSTF( FLAG_D );
		  nes_pc = (BYTE *)(ROMBANK3[ 0x1FFE ] | ROMBANK3[ 0x1FFF ] << 8);
		  encodePC;
#else
		++PC; PUSHW( PC ); SETF( FLAG_B ); PUSH( nes_F ); SETF( FLAG_I ); RSTF( FLAG_D );
		PC = ROMBANK2[ 0x3FFE ] | ROMBANK2[ 0x3FFF ] << 8;
#endif
		CLK( 7 );

		break;

      case 0x01:  // ORA (Zpg,nes_X)
        //ORA( A_IX ); CLK( 6 );

		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A |= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A |= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A |= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A |= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A |= RAM[ wA0 ];
		else
			nes_A |= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 6 );

        break;

	  ////nesterJ
	  //case 0x02:  /* JAM */
	  //case 0x12:  /* JAM */
	  //case 0x22:  /* JAM */
	  //case 0x32:  /* JAM */
	  //case 0x42:  /* JAM */
	  //case 0x52:  /* JAM */
	  //case 0x62:  /* JAM */
	  //case 0x72:  /* JAM */
	  //case 0x92:  /* JAM */
	  //case 0xB2:  /* JAM */
	  //case 0xD2:  /* JAM */
	  //case 0xF2:  /* JAM */
   //      /* kill the CPU */
   //     g_dwPassedClocks = wClocks;

   //     break;

      case 0x05:  // ORA Zpg
        //ORA( A_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		nes_A |= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 3 );
		
		break;

      case 0x06:  // ASL Zpg
        //ASL( AA_ZP ); CLK( 5 );

		//加速
#ifdef killtable
		ReadPC( wA0 );
		ReadZp( wA0 );
		ASL;
		WriteZp( wA0, byD0 );
#else
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPC( wA0 );
		ReadZp( wA0 );
		SETF( g_ASLTable[ byD0 ].byFlag );
		WriteZp( wA0, g_ASLTable[ byD0 ].byValue );
#endif
		CLK( 5 );

        break;

      case 0x08:  // PHP
        SETF( FLAG_B ); PUSH( nes_F ); CLK( 3 );
        break;

      case 0x09:  // ORA #Oper
        //ORA( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_A |= *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_A |= ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_A |= ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_A |= RAM[ PC++ ];
#endif
		TEST( nes_A );
		CLK( 2 );

		break;

      case 0x0A:  // ASL nes_A
        ASLA; CLK( 2 );
        break;

      case 0x0D:  // ORA Abs
        //ORA( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A |= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A |= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A |= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A |= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A |= RAM[ wA0 ];
		else
			nes_A |= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0x0E:  // ASL Abs 
        //ASL( AA_ABS ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
		ReadZp( wA0 );
		ASL;
		WriteZp( wA0, byD0 );
#else
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
		Bit6502RAM( g_ASLTable[ byD0 ].byValue );
		SETF( g_ASLTable[ byD0 ].byFlag );
#endif
		CLK( 6 );

        break;

      case 0x10: // BPL Oper
        BRA( !( nes_F & FLAG_N ) );
        break;

      case 0x11: // ORA (Zpg),nes_Y
        //ORA( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A |= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A |= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A |= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A |= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A |= RAM[ wA1 ];
		else
			nes_A |= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 5 );

        break;

      case 0x15: // ORA Zpg,nes_X
        //ORA( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		nes_A |= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 4 );

		break;

      case 0x16: // ASL Zpg,nes_X
        //ASL( AA_ZPX ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCX( wA0 );
		ReadZp( wA0 );
		ASL;
		WriteZp( wA0, byD0 );
#else
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCX( wA0 );
		ReadZp( wA0 );
		SETF( g_ASLTable[ byD0 ].byFlag );
		WriteZp( wA0, g_ASLTable[ byD0 ].byValue );
#endif
		CLK( 6 );

        break;

      case 0x18: // CLC
        RSTF( FLAG_C ); CLK( 2 );
        break;

      case 0x19: // ORA Abs,nes_Y
        //ORA( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A |= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A |= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A |= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A |= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A |= RAM[ wA1 ];
		else
			nes_A |= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x1D: // ORA Abs,nes_X
        //ORA( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A |= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A |= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A |= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A |= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A |= RAM[ wA1 ];
		else
			nes_A |= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x1E: // ASL Abs,nes_X
        //ASL( AA_ABSX ); CLK( 7 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
        wA0 += nes_X;
		ReadZp( wA0 );
		ASL;
		WriteZp( wA0, byD0 );
#else
        RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
        wA0 += nes_X;
		Bit6502RAM( g_ASLTable[ byD0 ].byValue );
		SETF( g_ASLTable[ byD0 ].byFlag );
#endif
        CLK( 7 );

        break;

      case 0x20: // JSR Abs
        //JSR; CLK( 6 );
        
		//加速
#if PocketNES == 1
		  wA0 = *nes_pc++;
		  wA0 |= *nes_pc << 8;
		  nes_pc -= (DWORD)lastbank;
		  PUSHW( (WORD)nes_pc );
		  nes_pc = (BYTE *)wA0;
		  encodePC;
#else
		if( PC >= 0xC000 )
		{
			wA0 = ROMBANK2[ PC++ & 0x3fff ];
			wA0 |= (WORD)ROMBANK2[ PC & 0x3fff ] << 8;
		}
		else if( PC >= 0x8000 )
		{
			wA0 = ROMBANK0[ PC++ & 0x3fff ];
			wA0 |= (WORD)ROMBANK0[ PC & 0x3fff ] << 8;
		}
		else
		{
			wA0 = RAM[ PC++ ];
			wA0 |= (WORD)RAM[ PC ] << 8;
		}
        PUSHW( PC );
		PC = wA0;
#endif
        CLK( 6 );

        break;

      case 0x21: // AND (Zpg,nes_X)
        //AND( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A &= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A &= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A &= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A &= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A &= RAM[ wA0 ];
		else
			nes_A &= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 6 );

		break;

      case 0x24: // BIT Zpg
        //BIT( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		ReadZp( wA0 );
		RSTF( FLAG_N | FLAG_V | FLAG_Z );
		SETF( ( byD0 & ( FLAG_N | FLAG_V ) ) | ( ( byD0 & nes_A ) ? 0 : FLAG_Z ) );
		CLK( 3 );

        break;

      case 0x25: // AND Zpg
        //AND( A_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		nes_A &= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 3 );
		
        break;

      case 0x26: // ROL Zpg
        //ROL( AA_ZP ); CLK( 5 );

		//加速
#ifdef killtable
		ReadPC( wA0 );
		ReadZp( wA0 );
		ROL;
		WriteZp( wA0, byD0 );
#else
		byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPC( wA0 );
		ReadZp( wA0 );
		SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag );
		WriteZp( wA0, g_ROLTable[ byD1 ][ byD0 ].byValue );
#endif
		CLK( 5 );

        break;

      case 0x28: // PLP
        POP( nes_F ); SETF( FLAG_R ); CLK( 4 );
        break;

      case 0x29: // AND #Oper
        //AND( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_A &= *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_A &= ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_A &= ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_A &= RAM[ PC++ ];
#endif
		TEST( nes_A );
		CLK( 2 );

        break;

      case 0x2A: // ROL nes_A
        ROLA; CLK( 2 );
        break;

      case 0x2C: // BIT Abs
        //BIT( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		byD0 = memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		byD0 = K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			byD0 = ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			byD0 = ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			byD0 = RAM[ wA0 ];
		else
			byD0 = K6502_ReadIO( wA0 );
#endif
        RSTF( FLAG_N | FLAG_V | FLAG_Z );
		SETF( ( byD0 & ( FLAG_N | FLAG_V ) ) | ( ( byD0 & nes_A ) ? 0 : FLAG_Z ) );
		CLK( 4 );

        break;

      case 0x2D: // AND Abs 
        //AND( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A &= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A &= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A &= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A &= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A &= RAM[ wA0 ];
		else
			nes_A &= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0x2E: // ROL Abs
        //ROL( AA_ABS ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
		ReadZp( wA0 );
		ROL;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
		Bit6502RAM( g_ROLTable[ byD1 ][ byD0 ].byValue );
		SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag );
#endif
		CLK( 6 );

        break;

#ifdef damnBIN
	  case 0xEF:
#endif /* damnBIN */
      case 0x30: // BMI Oper 
        BRA( nes_F & FLAG_N );
        break;

      case 0x31: // AND (Zpg),nes_Y
        //AND( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A &= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A &= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A &= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A &= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A &= RAM[ wA1 ];
		else
			nes_A &= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 5 );

        break;

      case 0x35: // AND Zpg,nes_X
        //AND( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		nes_A &= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0x36: // ROL Zpg,nes_X
        //ROL( AA_ZPX ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCX( wA0 );
		ReadZp( wA0 );
		ROL;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCX( wA0 );
		ReadZp( wA0 );
		SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag );
		WriteZp( wA0, g_ROLTable[ byD1 ][ byD0 ].byValue );
#endif
		CLK( 6 );

        break;

      case 0x38: // SEC
        SETF( FLAG_C ); CLK( 2 );
        break;

      case 0x39: // AND Abs,nes_Y
        //AND( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A &= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A &= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A &= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A &= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A &= RAM[ wA1 ];
		else
			nes_A &= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x3D: // AND Abs,nes_X
        //AND( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A &= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A &= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A &= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A &= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A &= RAM[ wA1 ];
		else
			nes_A &= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x3E: // ROL Abs,nes_X
        //ROL( AA_ABSX ); CLK( 7 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
        wA0 += nes_X;
		ReadZp( wA0 );
		ROL;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
        wA0 += nes_X;
		Bit6502RAM( g_ROLTable[ byD1 ][ byD0 ].byValue );
		SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag );
#endif
		CLK( 7 );

        break;

      case 0x40: // RTI
        POP( nes_F ); SETF( FLAG_R );
#if PocketNES == 1
		nes_pc = (BYTE *)RAM[ BASE_STACK + ++nes_SP ];
		nes_pc += RAM[ BASE_STACK + ++nes_SP ] << 8;
		encodePC;
#else
		POPW( PC );
#endif
		CLK( 6 );
        break;

      case 0x41: // EOR (Zpg,nes_X)
        //EOR( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A ^= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A ^= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A ^= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A ^= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A ^= RAM[ wA0 ];
		else
			nes_A ^= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 6 );

        break;

      case 0x45: // EOR Zpg
        //EOR( A_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		nes_A ^= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 3 );
		
        break;

      case 0x46: // LSR Zpg
        //LSR( AA_ZP ); CLK( 5 );
        
		//加速
#ifdef killtable
		ReadPC( wA0 );
		ReadZp( wA0 );
		LSR;
		WriteZp( wA0, byD0 );
#else
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPC( wA0 );
		ReadZp( wA0 );
		SETF( g_LSRTable[ byD0 ].byFlag );
		WriteZp( wA0, g_LSRTable[ byD0 ].byValue );
#endif
		CLK( 5 );

        break;

      case 0x48: // PHA
        PUSH( nes_A ); CLK( 3 );
        break;

      case 0x49: // EOR #Oper
        //EOR( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_A ^= *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_A ^= ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_A ^= ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_A ^= RAM[ PC++ ];
#endif
		TEST( nes_A );
		CLK( 2 );

        break;

      case 0x4A: // LSR nes_A
        LSRA; CLK( 2 );
        break;

#ifdef damnBIN
	  case 0xF7:
	  case 0xFF:
#endif /* damnBIN */
      case 0x4C: // JMP Abs
        //JMP( AA_ABS ); CLK( 3 );

		//加速
#if PocketNES == 1
		  wA0 = *nes_pc++;
		  nes_pc = (BYTE *)( wA0 | *nes_pc << 8 );
		  encodePC;
#else
		if( PC >= 0xC000 )
		{
			wA0 = ROMBANK2[ PC++ & 0x3fff ];
			PC = wA0 | ROMBANK2[ PC & 0x3fff ] << 8;
		}
		else if( PC >= 0x8000 )
		{
			wA0 = ROMBANK0[ PC++ & 0x3fff ];
			PC = wA0 | ROMBANK0[ PC & 0x3fff ] << 8;
		}
		else
		{
			wA0 = RAM[ PC++ ];
			PC = wA0 | RAM[ PC ] << 8;
		}
#endif
		CLK( 3 );

        break;

      case 0x4D: // EOR Abs
        //EOR( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A ^= memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A ^= K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A ^= ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A ^= ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A ^= RAM[ wA0 ];
		else
			nes_A ^= K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0x4E: // LSR Abs
        //LSR( AA_ABS ); CLK( 6 );

		//加速
#ifdef killtable
		ReadPCW( wA0 );
		ReadZp( wA0 );
		LSR;
		WriteZp( wA0, byD0 );
#else
        RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
		Bit6502RAM( g_LSRTable[ byD0 ].byValue );
		SETF( g_LSRTable[ byD0 ].byFlag );
#endif
		CLK( 6 );

        break;

      case 0x50: // BVC
        BRA( !( nes_F & FLAG_V ) );
        break;

      case 0x51: // EOR (Zpg),nes_Y
        //EOR( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A ^= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A ^= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A ^= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A ^= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A ^= RAM[ wA1 ];
		else
			nes_A ^= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 5 );

        break;

      case 0x55: // EOR Zpg,nes_X
        //EOR( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		nes_A ^= RAM[ wA0 ];
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0x56: // LSR Zpg,nes_X
        //LSR( AA_ZPX ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCX( wA0 );
		ReadZp( wA0 );
		LSR;
		WriteZp( wA0, byD0 );
#else
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCX( wA0 );
		ReadZp( wA0 );
		SETF( g_LSRTable[ byD0 ].byFlag );
		WriteZp( wA0, g_LSRTable[ byD0 ].byValue );
#endif
		CLK( 6 );

        break;

      case 0x58: // CLI
        //byD0 = nes_F;
        //RSTF( FLAG_I ); CLK( 2 );
        //if ( ( byD0 & FLAG_I ) && IRQ_State != IRQ_Wiring )  
        //{
        //  IRQ_State = IRQ_Wiring;          
        //  CLK( 7 );

        //  PUSHW( PC );
        //  PUSH( nes_F & ~FLAG_B );

        //  RSTF( FLAG_D );
        //  SETF( FLAG_I );
    
        //  PC = ROMBANK2[ 0x3FFE ] | ROMBANK2[ 0x3FFF ] << 8;//加速 K6502_ReadW( VECTOR_IRQ );
        //}
        
		//FCEU
		RSTF( FLAG_I ); CLK( 2 );

        break;

      case 0x59: // EOR Abs,nes_Y
        //EOR( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A ^= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A ^= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A ^= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A ^= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A ^= RAM[ wA1 ];
		else
			nes_A ^= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x5D: // EOR Abs,nes_X
        //EOR( A_ABSX ); CLK( 4 );
        
		//加速
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A ^= memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A ^= K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A ^= ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A ^= ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A ^= RAM[ wA1 ];
		else
			nes_A ^= K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
        CLK( 4 );

        break;

      case 0x5E: // LSR Abs,nes_X
        //LSR( AA_ABSX ); CLK( 7 );

		//加速
#ifdef killtable
		ReadPCW( wA0 );
        wA0 += nes_X;
		ReadZp( wA0 );
		LSR;
		WriteZp( wA0, byD0 );
#else
        RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
        wA0 += nes_X;
		Bit6502RAM( g_LSRTable[ byD0 ].byValue );
		SETF( g_LSRTable[ byD0 ].byFlag );
#endif
        CLK( 7 );

		break;

      case 0x60: // RTS
#if PocketNES == 1
		  nes_pc = (BYTE *)RAM[ BASE_STACK + ++nes_SP ];
		  nes_pc += RAM[ BASE_STACK + ++nes_SP ] << 8;
		  ++nes_pc;
		  encodePC;
#else
        POPW( PC ); ++PC;
#endif
		CLK( 6 );
        break;

      case 0x61: // ADC (Zpg,nes_X)
        //ADC( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
		Read6502RAM( wA0 );
        wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) );
		nes_A = byD1;
		CLK( 6 );

		break;

      case 0x65: // ADC Zpg
        //ADC( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		ReadZp( wA0 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) );
		nes_A = byD1;
		CLK( 3 );

        break;

      case 0x66: // ROR Zpg
        //ROR( AA_ZP ); CLK( 5 );

		//加速
#ifdef killtable
		ReadPC( wA0 );
		ReadZp( wA0 );
		ROR;
		WriteZp( wA0, byD0 );
#else
		byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPC( wA0 );
		ReadZp( wA0 );
		SETF( g_RORTable[ byD1 ][ byD0 ].byFlag );
		WriteZp( wA0, g_RORTable[ byD1 ][ byD0 ].byValue );
#endif
		CLK( 5 );

        break;

      case 0x68: // PLA
        POP( nes_A ); TEST( nes_A ); CLK( 4 );
        break;

      case 0x69: // ADC #Oper
        //ADC( A_IMM ); CLK( 2 );
        
		//加速
		ReadPC( byD0 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) );
		nes_A = byD1;
		CLK( 2 );

        break;

      case 0x6A: // ROR nes_A
        RORA; CLK( 2 );
        break;

      case 0x6C: // JMP (Abs)
        //JMP( K6502_ReadW2( AA_ABS ) ); CLK( 5 );

		//加速
#if PocketNES == 1
		  wA0 = *nes_pc++;
		  wA0 |= *nes_pc << 8;

#ifdef killif
		  wA1 = wA0 >> 13;
		  nes_pc = (BYTE *)( ( *readmem_tbl[ wA1 ] )( wA0 ) | (WORD)( ( *readmem_tbl[ wA1 ] )( wA0 + 1 ) ) << 8 );
#else /* killif */

#ifdef killif2
		  wA1 = wA0 >> 13;
		  nes_pc = (BYTE *)( memmap_tbl[ wA1 ][ wA0 ] | (WORD)( memmap_tbl[ wA1 ][ wA0 + 1 ] ) << 8 );
#else /* killif2 */
		  if( wA0 >= 0xC000 )
			  nes_pc = (BYTE *)( ROMBANK2[ wA0 & 0x3fff ] | (WORD)ROMBANK2[ ( wA0 + 1 ) & 0x3fff ] << 8 );
		  else if( wA0 >= 0x8000 )
			  nes_pc = (BYTE *)( ROMBANK0[ wA0 & 0x3fff ] | (WORD)ROMBANK0[ ( wA0 + 1 ) & 0x3fff ] << 8 );
		  else
			  nes_pc = (BYTE *)( RAM[ wA0 ] | (WORD)RAM[ wA0 + 1 ] << 8 );
#endif /* killif2 */

#endif /* killif */

		  encodePC;
#else
		if( PC >= 0xC000 )
		{
			wA0 = ROMBANK2[ PC++ & 0x3fff ];
			wA0 |= (WORD)ROMBANK2[ PC & 0x3fff ] << 8;
		}
		else if( PC >= 0x8000 )
		{
			wA0 = ROMBANK0[ PC++ & 0x3fff ];
			wA0 |= (WORD)ROMBANK0[ PC & 0x3fff ] << 8;
		}
		else
		{
			wA0 = RAM[ PC++ ];
			wA0 |= (WORD)RAM[ PC ] << 8;
		}
		if ( 0x00ff == ( wA0 & 0x00ff ) )
			if( wA0 >= 0xC000 )
				PC = ROMBANK2[ wA0 & 0x3fff ] | (WORD)ROMBANK2[ wA0 & 0x3f00 ] << 8;
			else if( wA0 >= 0x8000 )
				PC = ROMBANK0[ wA0 & 0x3fff ] | (WORD)ROMBANK0[ wA0 & 0x3f00 ] << 8;
			else
				PC = RAM[ wA0 ] | (WORD)RAM[ wA0 & 0xff00 ] << 8;
        else
			if( wA0 >= 0xC000 )
				PC = ROMBANK2[ wA0 & 0x3fff ] | (WORD)ROMBANK2[ ( wA0 + 1 ) & 0x3fff ] << 8;
			else if( wA0 >= 0x8000 )
				PC = ROMBANK0[ wA0 & 0x3fff ] | (WORD)ROMBANK0[ ( wA0 + 1 ) & 0x3fff ] << 8;
			else
				PC = RAM[ wA0 ] | (WORD)RAM[ wA0 + 1 ] << 8;
#endif
		CLK( 5 );

        break;

      case 0x6D: // ADC Abs
        //ADC( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		Read6502RAM( wA0 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); 
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0x6E: // ROR Abs
        //ROR( AA_ABS ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
		ReadZp( wA0 );
		ROR;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
		Bit6502RAM( g_RORTable[ byD1 ][ byD0 ].byValue );
		SETF( g_RORTable[ byD1 ][ byD0 ].byFlag );
#endif
		CLK( 6 );

        break;

      case 0x70: // BVS
        BRA( nes_F & FLAG_V );
        break;

      case 0x71: // ADC (Zpg),nes_Y
        //ADC( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); 
		nes_A = byD1;
		CLK( 5 );

        break;

      case 0x75: // ADC Zpg,nes_X
        //ADC( A_ZPX ); CLK( 4 );
        
		//加速
		ReadPCX( wA0 );
		ReadZp( wA0 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); 
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0x76: // ROR Zpg,nes_X
        //ROR( AA_ZPX ); CLK( 6 );
        
		//加速
#ifdef killtable
		ReadPCX( wA0 );
		ReadZp( wA0 );
		ROR;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCX( wA0 );
		ReadZp( wA0 );
		SETF( g_RORTable[ byD1 ][ byD0 ].byFlag );
		WriteZp( wA0, g_RORTable[ byD1 ][ byD0 ].byValue );
#endif
		CLK( 6 );

        break;

      case 0x78: // SEI
        SETF( FLAG_I ); CLK( 2 );
        break;

      case 0x79: // ADC Abs,nes_Y
        //ADC( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); 
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0x7D: // ADC Abs,nes_X
        //ADC( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A + byD0 + ( nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ~( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); 
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0x7E: // ROR Abs,nes_X
        //ROR( AA_ABSX ); CLK( 7 );
        
		//加速
#ifdef killtable
		ReadPCW( wA0 );
        wA0 += nes_X;
		ReadZp( wA0 );
		ROR;
		WriteZp( wA0, byD0 );
#else
        byD1 = nes_F & FLAG_C;
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		ReadPCW( wA0 );
        wA0 += nes_X;
		Bit6502RAM( g_RORTable[ byD1 ][ byD0 ].byValue );
		SETF( g_RORTable[ byD1 ][ byD0 ].byFlag );
#endif
		CLK( 7 );

        break;

      case 0x81: // STA (Zpg,nes_X)
        //STA( AA_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
		Write6502RAM( wA0, nes_A );
		CLK( 6 );

		break;
      
      case 0x84: // STY Zpg
        //STY( AA_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		WriteZp( wA0, nes_Y );
		CLK( 3 );

        break;

      case 0x85: // STA Zpg
        //STA( AA_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		WriteZp( wA0, nes_A );
		CLK( 3 );

        break;

      case 0x86: // STX Zpg
        //STX( AA_ZP ); CLK( 3 );

		//加速
		ReadPC( wA0 );
		WriteZp( wA0, nes_X );
		CLK( 3 );

        break;

      case 0x88: // DEY
        --nes_Y; TEST( nes_Y ); CLK( 2 );
        break;

      case 0x8A: // TXA
        nes_A = nes_X; TEST( nes_A ); CLK( 2 );
        break;

      case 0x8C: // STY Abs
        //STY( AA_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		Write6502RAM( wA0, nes_Y );
		CLK( 4 );

        break;

      case 0x8D: // STA Abs
        //STA( AA_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		Write6502RAM( wA0, nes_A );
		CLK( 4 );

        break;

      case 0x8E: // STX Abs
        //STX( AA_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		Write6502RAM( wA0, nes_X );
		CLK( 4 );

        break;

#ifdef damnBIN
      case 0xF3:
#endif /* damnBIN */
      case 0x90: // BCC
        BRA( !( nes_F & FLAG_C ) );
        break;

      case 0x91: // STA (Zpg),nes_Y
        //STA( AA_IY ); CLK( 6 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		Write6502RAM( wA1, nes_A );
		CLK( 6 );

        break;

      case 0x94: // STY Zpg,nes_X
        //STY( AA_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		WriteZp( wA0, nes_Y );
		CLK( 4 );

        break;

      case 0x95: // STA Zpg,nes_X
        //STA( AA_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		WriteZp( wA0, nes_A );
		CLK( 4 );

        break;

      case 0x96: // STX Zpg,nes_Y
        //STX( AA_ZPY ); CLK( 4 );
        
		//加速
        ReadPCY( wA0 );
		WriteZp( wA0, nes_X );
		CLK( 4 );

        break;

      case 0x98: // TYA
        nes_A = nes_Y; TEST( nes_A ); CLK( 2 );
        break;

      case 0x99: // STA Abs,nes_Y
        //STA( AA_ABSY ); CLK( 5 );
        
		//加速
		ReadPCW( wA0 );
		wA0 += nes_Y;
		Write6502RAM( wA0, nes_A );
		CLK( 5 );

        break;

      case 0x9A: // TXS
        nes_SP = nes_X; CLK( 2 );
        break;

      case 0x9D: // STA Abs,nes_X
        //STA( AA_ABSX ); CLK( 5 );
        
		//加速
		ReadPCW( wA0 );
		wA0 += nes_X;
		Write6502RAM( wA0, nes_A );
		CLK( 5 );

        break;

      case 0xA0: // LDY #Oper
        //LDY( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_Y = *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_Y = ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_Y = ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_Y = RAM[ PC++ ];
#endif
		TEST( nes_Y );
		CLK( 2 );

        break;

      case 0xA1: // LDA (Zpg,nes_X)
        //LDA( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A = memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A = K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A = ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A = ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A = RAM[ wA0 ];
		else
			nes_A = K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 6 );

		break;

      case 0xA2: // LDX #Oper
        //LDX( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_X = *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_X = ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_X = ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_X = RAM[ PC++ ];
#endif
		TEST( nes_X );
		CLK( 2 );

        break;

      case 0xA4: // LDY Zpg
        //LDY( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		nes_Y = RAM[ wA0 ];
		TEST( nes_Y );
		CLK( 3 );

        break;

      case 0xA5: // LDA Zpg
        //LDA( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		nes_A = RAM[ wA0 ];
		TEST( nes_A );
		CLK( 3 );

        break;

      case 0xA6: // LDX Zpg
        //LDX( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		nes_X = RAM[ wA0 ];
		TEST( nes_X );
		CLK( 3 );

        break;

      case 0xA8: // TAY
        nes_Y = nes_A; TEST( nes_A ); CLK( 2 );
        break;

      case 0xA9: // LDA #Oper
        //LDA( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  nes_A = *nes_pc++;
#else
		if( PC >= 0xC000 )
			nes_A = ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			nes_A = ROMBANK0[ PC++ & 0x3fff ];
		else
			nes_A = RAM[ PC++ ];
#endif
		TEST( nes_A );
		CLK( 2 );

        break;

      case 0xAA: // TAX
        nes_X = nes_A; TEST( nes_A ); CLK( 2 );
        break;

      case 0xAC: // LDY Abs
        //LDY( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_Y = memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_Y = K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_Y = ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_Y = ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_Y = RAM[ wA0 ];
		else
			nes_Y = K6502_ReadIO( wA0 );
#endif
		TEST( nes_Y );
		CLK( 4 );

        break;

      case 0xAD: // LDA Abs
        //LDA( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_A = memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_A = K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_A = ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_A = ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_A = RAM[ wA0 ];
		else
			nes_A = K6502_ReadIO( wA0 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0xAE: // LDX Abs
        //LDX( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		nes_X = memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		nes_X = K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			nes_X = ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			nes_X = ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			nes_X = RAM[ wA0 ];
		else
			nes_X = K6502_ReadIO( wA0 );
#endif
		TEST( nes_X );
		CLK( 4 );

        break;

      case 0xB0: // BCS
        BRA( nes_F & FLAG_C );
        break;

      case 0xB1: // LDA (Zpg),nes_Y
        //LDA( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A = memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A = K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A = ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A = ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A = RAM[ wA1 ];
		else
			nes_A = K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 5 );

        break;

      case 0xB4: // LDY Zpg,nes_X
        //LDY( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		nes_Y = RAM[ wA0 ];
		TEST( nes_Y );
		CLK( 4 );

        break;

      case 0xB5: // LDA Zpg,nes_X
        //LDA( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		nes_A = RAM[ wA0 ];
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0xB6: // LDX Zpg,nes_Y
        //LDX( A_ZPY ); CLK( 4 );
        
		//加速
        ReadPCY( wA0 );
		nes_X = RAM[ wA0 ];
		TEST( nes_X );
		CLK( 4 );

        break;

      case 0xB8: // CLV
        RSTF( FLAG_V ); CLK( 2 );
        break;

      case 0xB9: // LDA Abs,nes_Y
        //LDA( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A = memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A = K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A = ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A = ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A = RAM[ wA1 ];
		else
			nes_A = K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0xBA: // TSX
        nes_X = nes_SP; TEST( nes_X ); CLK( 2 );
        break;

      case 0xBC: // LDY Abs,nes_X
        //LDY( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_Y = memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_Y = K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_Y = ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_Y = ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_Y = RAM[ wA1 ];
		else
			nes_Y = K6502_ReadIO( wA1 );
#endif
		TEST( nes_Y );
		CLK( 4 );

        break;

      case 0xBD: // LDA Abs,nes_X
        //LDA( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_A = memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_A = K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_A = ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_A = ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_A = RAM[ wA1 ];
		else
			nes_A = K6502_ReadIO( wA1 );
#endif
		TEST( nes_A );
		CLK( 4 );

        break;

      case 0xBE: // LDX Abs,nes_Y
        //LDX( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		nes_X = memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		nes_X = K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			nes_X = ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			nes_X = ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			nes_X = RAM[ wA1 ];
		else
			nes_X = K6502_ReadIO( wA1 );
#endif
		TEST( nes_X );
		CLK( 4 );

        break;

      case 0xC0: // CPY #Oper
        //CPY( A_IMM ); CLK( 2 );
        
		//加速
#if PocketNES == 1
		  wD0 = nes_Y - *nes_pc++;
#else
		if( PC >= 0xC000 )
			wD0 = nes_Y - ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			wD0 = nes_Y - ROMBANK0[ PC++ & 0x3fff ];
		else
			wD0 = nes_Y - RAM[ PC++ ];
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 2 );

        break;

      case 0xC1: // CMP (Zpg,nes_X)
        //CMP( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		wD0 = nes_A - memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		wD0 = nes_A - K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			wD0 = nes_A - RAM[ wA0 ];
		else
			wD0 = nes_A - K6502_ReadIO( wA0 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 6 );

        break;

      case 0xC4: // CPY Zpg
        //CPY( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		wD0 = nes_Y - RAM[ wA0 ];
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 3 );

        break;

      case 0xC5: // CMP Zpg
        //CMP( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		wD0 = nes_A - RAM[ wA0 ];
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 3 );

        break;

      case 0xC6: // DEC Zpg
        //DEC( AA_ZP ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZp( wA0 );
		--byD0;
		WriteZp( wA0, byD0 );
		TEST( byD0 );
		CLK( 5 );

        break;

      case 0xC8: // INY
        ++nes_Y; TEST( nes_Y ); CLK( 2 );
        break;

      case 0xC9: // CMP #Oper
        //CMP( A_IMM ); CLK( 2 );

		//加速
#if PocketNES == 1
		  wD0 = nes_A - *nes_pc++;
#else
		if( PC >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ PC++ & 0x3fff ];
		else
			wD0 = nes_A - RAM[ PC++ ];
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 2 );

        break;

      case 0xCA: // DEX
        --nes_X; TEST( nes_X ); CLK( 2 );
        break;

      case 0xCC: // CPY Abs
        //CPY( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		wD0 = nes_Y - memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		wD0 = nes_Y - K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			wD0 = nes_Y - ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			wD0 = nes_Y - ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			wD0 = nes_Y - RAM[ wA0 ];
		else
			wD0 = nes_Y - K6502_ReadIO( wA0 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );

        break;

      case 0xCD: // CMP Abs
        //CMP( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		wD0 = nes_A - memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		wD0 = nes_A - K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			wD0 = nes_A - RAM[ wA0 ];
		else
			wD0 = nes_A - K6502_ReadIO( wA0 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );

        break;

      case 0xCE: // DEC Abs
        //DEC( AA_ABS ); CLK( 6 );
        
		//加速
		ReadPCW( wA0 );
		DEC6502RAM;
		TEST( byD0 );
		CLK( 6 );

        break;

#ifdef damnBIN
      case 0xF2:
      case 0xFB:
#endif /* damnBIN */
      case 0xD0: // BNE
        BRA( !( nes_F & FLAG_Z ) );
        break;

      case 0xD1: // CMP (Zpg),nes_Y
        //CMP( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		wD0 = nes_A - memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		wD0 = nes_A - K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			wD0 = nes_A - RAM[ wA1 ];
		else
			wD0 = nes_A - K6502_ReadIO( wA1 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 5 );

        break;

      case 0xD5: // CMP Zpg,nes_X
        //CMP( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		wD0 = nes_A - RAM[ wA0 ];
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );

        break;

      case 0xD6: // DEC Zpg,nes_X
        //DEC( AA_ZPX ); CLK( 6 );
        
		//加速
        ReadPCX( wA0 );
		ReadZp( wA0 );
		--byD0;
		WriteZp( wA0, byD0 );
		TEST( byD0 );
		CLK( 6 );

        break;

      case 0xD8: // CLD
        RSTF( FLAG_D ); CLK( 2 );
        break;

      case 0xD9: // CMP Abs,nes_Y
        //CMP( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		wD0 = nes_A - memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		wD0 = nes_A - K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			wD0 = nes_A - RAM[ wA1 ];
		else
			wD0 = nes_A - K6502_ReadIO( wA1 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );

        break;

      case 0xDD: // CMP Abs,nes_X
        //CMP( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
#ifdef killif3
	if( wA1 >= 0x8000 || wA1 < 0x2000 )
		wD0 = nes_A - memmap_tbl[ wA1 >> 13 ][ wA1 ];
	else
		wD0 = nes_A - K6502_ReadIO( wA1 );
#else /* killif3 */
		if( wA1 >= 0xC000 )
			wD0 = nes_A - ROMBANK2[ wA1 & 0x3fff ];
		else if( wA1 >= 0x8000 )
			wD0 = nes_A - ROMBANK0[ wA1 & 0x3fff ];
		else if( wA1 < 0x2000 )
			wD0 = nes_A - RAM[ wA1 ];
		else
			wD0 = nes_A - K6502_ReadIO( wA1 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );

        break;

      case 0xDE: // DEC Abs,nes_X
        //DEC( AA_ABSX ); CLK( 7 );
        
		//加速
		ReadPCW( wA0 );
		wA0 += nes_X;
		DEC6502RAM;
		TEST( byD0 );
		CLK( 7 );

        break;

      case 0xE0: // CPX #Oper
        //CPX( A_IMM ); CLK( 2 );
        
		//加速
#if PocketNES == 1
		  wD0 = nes_X - *nes_pc++;
#else
		if( PC >= 0xC000 )
			wD0 = nes_X - ROMBANK2[ PC++ & 0x3fff ];
		else if( PC >= 0x8000 )
			wD0 = nes_X - ROMBANK0[ PC++ & 0x3fff ];
		else
			wD0 = nes_X - RAM[ PC++ ];
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 2 );

        break;

      case 0xE1: // SBC (Zpg,nes_X)
        //SBC( A_IX ); CLK( 6 );
        
		//加速
		ReadPCX( wA0 );
		ReadZpW( wA0 );
		Read6502RAM( wA0 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 6 );
		
		break;

      case 0xE4: // CPX Zpg
        //CPX( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		wD0 = nes_X - RAM[ wA0 ];
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 3 );

        break;

      case 0xE5: // SBC Zpg
        //SBC( A_ZP ); CLK( 3 );
        
		//加速
		ReadPC( wA0 );
		ReadZp( wA0 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 3 );

        break;

      case 0xE6: // INC Zpg
        //INC( AA_ZP ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZp( wA0 );
		++byD0;
		WriteZp( wA0, byD0 );
		TEST( byD0 );
		CLK( 5 );

        break;

      case 0xE8: // INX
        ++nes_X; TEST( nes_X ); CLK( 2 );
        break;

      case 0xE9: // SBC #Oper
        //SBC( A_IMM ); CLK( 2 );

		//加速
		ReadPC( byD0 );
        wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 2 );

        break;

      case 0xEA: // NOP
        CLK( 2 );
        break;

      case 0xEC: // CPX Abs
        //CPX( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
#ifdef killif3
	if( wA0 >= 0x8000 || wA0 < 0x2000 )
		wD0 = nes_X - memmap_tbl[ wA0 >> 13 ][ wA0 ];
	else
		wD0 = nes_X - K6502_ReadIO( wA0 );
#else /* killif3 */
		if( wA0 >= 0xC000 )
			wD0 = nes_X - ROMBANK2[ wA0 & 0x3fff ];
		else if( wA0 >= 0x8000 )
			wD0 = nes_X - ROMBANK0[ wA0 & 0x3fff ];
		else if( wA0 < 0x2000 )
			wD0 = nes_X - RAM[ wA0 ];
		else
			wD0 = nes_X - K6502_ReadIO( wA0 );
#endif
		RSTF( FLAG_N | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
		CLK( 4 );
        break;

      case 0xED: // SBC Abs
        //SBC( A_ABS ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		Read6502RAM( wA0 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0xEE: // INC Abs
        //INC( AA_ABS ); CLK( 6 );
        
		//加速
		ReadPCW( wA0 );
		INC6502RAM;
		TEST( byD0 );
		CLK( 6 );

        break;

#ifdef damnBIN
      case 0xF4:
      case 0xFA:
      case 0xFC:
#endif /* damnBIN */
      case 0xF0: // BEQ
        BRA( nes_F & FLAG_Z );
        break;

      case 0xF1: // SBC (Zpg),nes_Y
        //SBC( A_IY ); CLK( 5 );
        
		//加速
		ReadPC( wA0 );
		ReadZpW( wA0 );
		wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 5 );

        break;

      case 0xF5: // SBC Zpg,nes_X
        //SBC( A_ZPX ); CLK( 4 );
        
		//加速
        ReadPCX( wA0 );
		ReadZp( wA0 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0xF6: // INC Zpg,nes_X
        //INC( AA_ZPX ); CLK( 6 );
        
		//加速
        ReadPCX( wA0 );
		ReadZp( wA0 );
		++byD0;
		WriteZp( wA0, byD0 );
		TEST( byD0 );
		CLK( 6 );

        break;

      case 0xF8: // SED
        SETF( FLAG_D ); CLK( 2 );
        break;

      case 0xF9: // SBC Abs,nes_Y
        //SBC( A_ABSY ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
        wA1 = wA0 + nes_Y;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0xFD: // SBC Abs,nes_X
        //SBC( A_ABSX ); CLK( 4 );
        
		//加速
		ReadPCW( wA0 );
		wA1 = wA0 + nes_X;
		CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) );
		Read6502RAM( wA1 );
		wD0 = nes_A - byD0 - ( ~nes_F & FLAG_C );
		byD1 = (BYTE)wD0;
		RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C );
		SETF( g_byTestTable[ byD1 ] | ( ( ( nes_A ^ byD0 ) & ( nes_A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) );
		nes_A = byD1;
		CLK( 4 );

        break;

      case 0xFE: // INC Abs,nes_X
        //INC( AA_ABSX ); CLK( 7 );
        
		//加速
		ReadPCW( wA0 );
		wA0 += nes_X;
		INC6502RAM;
		TEST( byD0 );
		CLK( 7 );

        break;

      /*-----------------------------------------------------------*/
      /*  Unlisted Instructions ( thanks to virtualnes )           */
      /*-----------------------------------------------------------*/

			case	0x1A: // NOP (Unofficial)
			case	0x3A: // NOP (Unofficial)
			case	0x5A: // NOP (Unofficial)
			case	0x7A: // NOP (Unofficial)
			case	0xDA: // NOP (Unofficial)
#ifndef damnBIN
			case	0xFA: // NOP (Unofficial)
#endif /* damnBIN */
				CLK( 2 );
				break;

			case	0x80: // DOP (CYCLES 2)
			case	0x82: // DOP (CYCLES 2)
			case	0x89: // DOP (CYCLES 2)
			case	0xC2: // DOP (CYCLES 2)
			case	0xE2: // DOP (CYCLES 2)
#if PocketNES == 1
				nes_pc++;
#else
				PC++;
#endif
				CLK( 2 );
				break;

			case	0x04: // DOP (CYCLES 3)
			case	0x44: // DOP (CYCLES 3)
			case	0x64: // DOP (CYCLES 3)
#if PocketNES == 1
				nes_pc++;
#else
				PC++;
#endif
				CLK( 3 );
				break;

			case	0x14: // DOP (CYCLES 4)
			case	0x34: // DOP (CYCLES 4)
			case	0x54: // DOP (CYCLES 4)
			case	0x74: // DOP (CYCLES 4)
			case	0xD4: // DOP (CYCLES 4)
			//case	0xF4: // DOP (CYCLES 4)
#if PocketNES == 1
				nes_pc++;
#else
				PC++;
#endif
        CLK( 4 );
        break;

			case	0x0C: // TOP
			case	0x1C: // TOP
			case	0x3C: // TOP
			case	0x5C: // TOP
			case	0x7C: // TOP
			case	0xDC: // TOP
#ifndef damnBIN
			case	0xFC: // TOP
#endif /* damnBIN */

#if PocketNES == 1
				nes_pc += 2;
#else
				PC += 2;
#endif
				CLK( 4 );
				break;

      default:   // Unknown Instruction
        CLK( 2 );
//#if 0
//        InfoNES_MessageBox( "0x%02x is unknown instruction.\n", byCode ) ;
//#endif
        break;
        
    }  /* end of switch ( byCode ) */

  }  /* end of while ... */

  // Correct the number of the clocks
  g_dwPassedClocks -= wClocks;
}

//// Addressing Op.
//// Data
//// Absolute,nes_X
//static inline BYTE K6502_ReadAbsX(){ WORD wA0, wA1; wA0 = AA_ABS; wA1 = wA0 + nes_X; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };
//// Absolute,nes_Y
//static inline BYTE K6502_ReadAbsY(){ WORD wA0, wA1; wA0 = AA_ABS; wA1 = wA0 + nes_Y; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };
//// (Indirect),nes_Y
//static inline BYTE K6502_ReadIY(){ WORD wA0, wA1; wA0 = K6502_ReadZpW( K6502_ReadPC( PC++ ) ); wA1 = wA0 + nes_Y; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };

/*===================================================================*/
/*                                                                   */
/*                  6502 Reading/Writing Operation                   */
/*                                                                   */
/*===================================================================*/
#include "K6502_rw.h"
